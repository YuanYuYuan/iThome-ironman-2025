# Zenoh 在機器人系統的應用全景 Part 4 - 深入探討 rmw_zenoh，新一代的ROS 2 Middleware

> *突破性 middleware 如何革命化機器人通訊，從單一機器人到廣域機器人群體*

---

想像一下：自主機器人正在東京的倉庫中導航，而我們在舊金山的辦公室中監控其進度。在雲端運行的控制演算法與機器人的載體系統無縫協調，就像它們在同一個房間裡一樣。同時，城市中的送貨無人機群組分享即時協調資料，儘管它們在品質變化的行動網路上運作，但仍能保持完美同步。

這不是科幻小說——這是現代機器人團隊今天正在建構的現實。但問題來了：**讓這一切成為可能的通訊骨幹一直是瓶頸**。

## 阻礙機器人發展的通訊挑戰

機器人世界本質上是分散式的。無論你是在協調無人機群、從地球另一端遙控機器人，還是建構擁有數十個處理單元的複雜自主車輛，一切都取決於一個關鍵因素：**你的元件彼此溝通得多好**。

在 ROS 2 生態系統中，這種通訊透過 RMW (ROS Middleware) 層發生——可以把它想像成讓機器人的大腦、感測器和致動器能夠對話的通用翻譯器。

多年來，ROS 依賴 DDS (Data Distribution Service) 實作。DDS 強大且經過實戰考驗，為機器人社群提供了出色的服務。但當我們推進新的前沿——**網際網路規模的機器人、邊緣到雲端的整合，以及大規模多機器人系統**——我們遇到了傳統 middleware 未設計來處理的障礙。

**痛點是真實的：**
- Multicast 探索會淹沒無線網路
- 網際網路連線的複雜配置
- 在有損網路條件下的脆弱行為
- 消耗移動機器人電池壽命的高負擔

這時 [Zenoh](https://github.com/eclipse-zenoh/zenoh) 帶來的一線曙光。更具體地說，對 ROS 2 社群而言，是 [rmw_zenoh](https://github.com/ros2/rmw_zenoh)。

## 技術堆疊：逐層建構通訊卓越性

在深入解決方案之前，讓我們了解是什麼讓 `rmw_zenoh_cpp` 如此強大。它建構在精心設計的堆疊上，每一層都有特定用途，從你的高層機器人應用程式到網路硬體：

```
┌─────────────────────────────────────────────────────────────┐
│                    ROS 2 Applications                       │
│              (your robots, nodes, launch files)             │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                   ROS 2 Client Libraries                    │
│                 (rclcpp, rclpy, rclc, etc.)                 │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                   RCL (ROS Client Library)                  │
│              (language-agnostic common functionality)       │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                     RMW Interface                           │
│                (standardized middleware API)                │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                     rmw_zenoh_cpp                           │ ← This is where the magic happens
│              (Zenoh RMW implementation for C++)             │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                     zenoh-cpp                               │
│                (C++ bindings for Zenoh)                     │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                       zenoh-c                               │
│              (C API wrapper around Zenoh core)              │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    Zenoh (Rust Core)                        │
│        (high-performance pub/sub/query protocol engine)     │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                Network Transport Layer                      │
│         (TCP, UDP, Unix sockets, shared memory, etc.)       │
└─────────────────────────────────────────────────────────────┘
```

在基礎層，Zenoh 核心（用 Rust 編寫以獲得最大效能和安全性）處理複雜的網路、路由和協定細節。C 和 C++ 綁定提供符合人體工學的 API，而 `rmw_zenoh` 將 ROS 2 語意轉換為 Zenoh 操作。

**這種分層方法的美妙之處在於** 你現有的 ROS 2 應用程式完全保持不變——它們仍然使用熟悉的 `rclcpp` 或 `rclpy` API。但在底層，它們獲得了 Zenoh 先進網路功能的存取權：無縫 WAN 通訊、強健的探索和最佳化的傳輸選擇。


**對機器人團隊而言，這些功能解決了重大挑戰：**
- ✅ 透過 4G/5G 網路的遙控操作
- ✅ 在挑戰性 RF 環境中的多機器人協調
- ✅ 無需複雜 VPN 設定的雲端到邊緣整合
- ✅ 無縫的模擬到硬體橋接

---

## rmw_zenoh：ROS 2 與未來的交會點

`rmw_zenoh` 是 **官方 RMW 實作**，無縫整合 Zenoh 的革命性網路功能到 ROS 2 生態系統中。

**轉換異常簡單：** 透過將預設的 DDS RMW 替換為 `rmw_zenoh`，你的 ROS 2 節點停止說 DDS 而開始說 Zenoh。**你不需要更改應用程式碼的任何一行**。你的 publisher、subscriber、service 和 action 完全如以前一樣工作——但現在它們由 Zenoh 的先進網路引擎驅動。

**這就像在機器人仍在運行時升級其神經系統。**

## 架構深入探討：rmw_zenoh 如何運作

要真正理解 `rmw_zenoh` 的威力，檢視其內部架構和設計決策至關重要。該實作代表了將 ROS 2 的通訊範式複雜地映射到 Zenoh 的網路原語上。

### 核心架構原則

**每 Context 一個 Session 設計：**
每個 ROS 2 "context"（middleware 配置）恰好映射到一個 Zenoh "session"。這意味著單一 context 內的所有 publisher、subscription、service 和 client 共享相同的底層 Zenoh session，最佳化資源使用和連線管理。

**Router 輔助探索與點對點資料流：**
該架構使用混合方法，利用中心化和去中心化設計的最佳部分：

1. **探索階段**：節點連接到本地 Zenoh router 進行探索和初始圖建構
2. **資料階段**：一旦被發現，節點建立直接點對點連線進行實際資料交換
3. **Router 獨立性**：探索後，進行中的通訊不再需要 router

這種設計提供了可靠的探索，同時保持直接點對點資料傳輸的效能優勢。

### 關鍵元件

**Graph Cache：ROS 2 整合的核心**
`rmw_zenoh` 最巧妙的方面之一是其 graph cache 系統。由於 Zenoh 優先考慮最小探索開銷，而 ROS 2 期望完整的圖可見性，每個 context 維護所有已發現實體的綜合快取：

- **Liveliness Token**：每個實體（node、publisher、subscriber、service）廣播包含其 metadata 的唯一 liveliness token
- **動態更新**：隨著實體加入和離開網路，快取持續更新
- **密封命名空間**：使用 Zenoh 的 `@ros2_lv` 前綴為 ROS 2 實體創建隔離的命名空間

**智慧 Key Expression 映射：**
Topic 和 service 使用複雜的方案映射到 Zenoh key expression，確保型別安全和域隔離：

```
<domain_id>/<fully_qualified_name>/<type_name>/<type_hash>
```

這種方法防止不同 ROS 域之間的交叉通訊，並確保只有相容的型別能夠通訊。

**Quality of Service 轉換：**
實作智慧地將 ROS 2 QoS 策略映射到 Zenoh 功能：
- `TRANSIENT_LOCAL` durability → Zenoh publication cache
- `RELIABLE` reliability → TCP 傳輸選擇
- `KEEP_ALL` history → Congestion control blocking mode + Queue

### 網路拓樸與配置

預設網路拓樸經過精心設計以獲得最佳效能：

```
Local Zenoh Router (tcp/[::]:7447)
       ↑
       │ (discovery only)
       ↓
   ROS 2 Sessions ←→ Direct P2P connections (data)
```

**預設配置：**
- **Session**：連接到 `tcp/localhost:7447`，在隨機 loopback port 上監聽
- **Router**：在 port 7447 上監聽所有介面
- **探索**：啟用 Gossip scouting，停用 UDP multicast（為了網路可靠性）

### 解析

**訊息的CDR 序列化策略：**
- **無需新 Typesupport**：利用現有的 ROS 2 型別基礎設施
- 高效能：採用已經驗證多年的開源 FastCDR 做爲骨幹

**Attachment Metadata：**
每則訊息在 Zenoh attachment 中包含豐富的 metadata：
- 用於訊息排序的序列號
- 用於延遲測量的來源時間戳
- 用於圖關聯的 Publisher/client GID

**Service-to-Query 映射：**
ROS 2 service 優雅地映射到 Zenoh 的 query/reply 模式：
- Service client 發送帶有 `ALL_COMPLETE` 目標的 Zenoh query
- Service server 創建聲明為 "complete" 的 queryable
- 透過 attachment 中的序列號進行 Request/response 關聯

這種架構基礎使 `rmw_zenoh` 不只是簡單的協定轉換層，而是保持 ROS 2 語意同時解鎖 Zenoh 先進網路功能的複雜通訊系統。

---

## 為什麼 rmw_zenoh 對 ROS 2 至關重要？

以下是讓機器人切換到 `rmw_zenoh` 的具體好處：

### **網際網路規模機器人變得輕而易舉**
**殺手級功能:** 連接跨網際網路的 ROS 2 系統變得像連接到本地網路一樣簡單。在雲端部署 Zenoh router，將你的機器人和控制站指向它而無需自訂橋接程式碼。

### **重要的資源效率**
Zenoh 的超輕量級協定直接轉化為 **更低的 CPU 使用率、減少的記憶體佔用和延長的電池壽命**。對於資源受限的嵌入式系統，這不只是最佳化——這是可行與不可行的差別。

### **易學易用的配置**
簡單的 JSON5 配置檔案讓你精細調整一切：點對點 vs. router 模式、安全設定、傳輸選擇。**不再與 XML 配置噩夢搏鬥。**

### **無痛生態系統整合**
Zenoh 的路由功能實現與其他系統——MQTT、網路服務、雲端平台——的無縫整合。既存的 ROS 2 系統成為更大數位生態系統的一部分，無需自訂橋接解決方案。

---

## 如何使用

準備好轉換你的 ROS 2 通訊了嗎？RMW 層的美妙之處在於切換到不同實作異常將但。

### 基本設定 - 本地通訊
對於單主機通訊，你需要運行 Zenoh router：

```bash
# Terminal 1: Start the Zenoh router
export RMW_IMPLEMENTATION=rmw_zenoh_cpp
ros2 run rmw_zenoh_cpp rmw_zenohd

# Terminal 2: Run your talker
export RMW_IMPLEMENTATION=rmw_zenoh_cpp
ros2 run demo_nodes_cpp talker

# Terminal 3: Run your listener
export RMW_IMPLEMENTATION=rmw_zenoh_cpp
ros2 run demo_nodes_cpp listener
```


### 理解 Zenoh 架構
與傳統 DDS 實作不同，Zenoh 使用基於 router 的架構進行探索，但然後建立直接點對點連線進行資料傳輸。當 ROS 節點啟動時：

1. 它連接到本地 Zenoh router (`rmw_zenohd`)
2. Router 促進與其他節點的探索
3. 節點建立直接點對點連線
4. 資料交換不再需要 router

這種設計提供了兩全其美的好處：簡單的探索和高效的直接通訊。


### 配置管理

`rmw_zenoh` 使用兩個關鍵配置檔案：
- `DEFAULT_RMW_ZENOH_ROUTER_CONFIG.json5` - 用於 Zenoh router
- `DEFAULT_RMW_ZENOH_SESSION_CONFIG.json5` - 用於 ROS 節點

可以透過從安裝目錄複製來自訂這些：

```bash
# Copy default configs for customization
cp /opt/ros/${ROS_DISTRO}/share/rmw_zenoh_cpp/config/DEFAULT_RMW_ZENOH_ROUTER_CONFIG.json5 ./router_config.json5
cp /opt/ros/${ROS_DISTRO}/share/rmw_zenoh_cpp/config/DEFAULT_RMW_ZENOH_SESSION_CONFIG.json5 ./session_config.json5

# Use custom configs
export ZENOH_ROUTER_CONFIG_URI=./router_config.json5
export ZENOH_SESSION_CONFIG_URI=./session_config.json5
```

### 遠端通訊
對於 WAN 通訊或連接多個主機，修改你的配置以連接到遠端 router：

```json5
// session_config.json5
{
  mode: "client",  // Important for remote connections
  connect: {
    endpoints: ["tcp/your.robot.ip:7447"]
  }
}
```

### 共享記憶體

要傳遞大資料時，可選擇啟用 shared memory 以減少延遲：

```json5
// In your config files
{
  transport: {
    shared_memory: {
      enabled: true
    }
  }
}
```

### 配置覆寫

也可以透過環境變數直接替換配置功能，是不是很方便呢？

```bash
# Enable multicast scouting for peer discovery without router
ZENOH_CONFIG_OVERRIDE='scouting/multicast/enabled=true' ros2 run demo_nodes_cpp talker
```

### 實際部署模式

**模式 1：雲端連接機器人**
- 在具有公共 IP 的雲端中運行 Zenoh router
- 配置機器人和控制站連接到雲端 router
- 實現無縫遙控操作和監控

**模式 2：多機器人系統**
- 每個機器人運行自己的本地 Zenoh router
- Router 彼此連接，創建 mesh 網路
- 整個機器人群的自動探索和通訊

**模式 3：邊緣到雲端整合**
- 用於即時控制迴路的本地 Zenoh router
- 用於資料記錄和遠端監控的雲端 router 次要連線
- 效能和連接性的最佳平衡

---

## rmw_zenoh vs zenoh-plugin-ros2dds：通往 Zenoh 的兩條路徑

> 如果你想更深入了解 zenoh-plugin-ros2dds 的詳細內容，可以參考我們之前的文章：[Day 25: Zenoh 在機器人系統的應用全景 Part 2 - ROS 2 與 zenoh-plugin-ros2dds](https://ithelp.ithome.com.tw/articles/10391014)

在探索 ROS 2 的 Zenoh 生態系統時，你會遇到兩種不同的方法：`rmw_zenoh` 和 `zenoh-plugin-ros2dds`。理解它們的差異對於為你的應用程式選擇正確的工具至關重要。

### 架構哲學

**rmw_zenoh：原生 RMW 方法**
- **直接整合**：在 RMW 層完全替換 DDS
- **原生 ROS 2**：你的應用程式從頭到尾在純 Zenoh 上運行
- **單一協定**：所有通訊透過 Zenoh 的原生協定進行
- **零轉換開銷**：不需要 DDS 到 Zenoh 的轉換

**zenoh-plugin-ros2dds：Bridge 方法**
- **混合架構**：保持現有的 DDS 基礎設施並橋接到 Zenoh
- **轉換層**：作為 DDS 和 Zenoh 網路之間的智慧橋樑
- **漸進遷移**：允許漸進採用而不改變現有節點
- **協定轉換**：動態地在 DDS 和 Zenoh 語意之間轉換

### 何時選擇每種方法

**選擇 rmw_zenoh 當：**
- 你想要最大效能和最小開銷
- 你的整個系統可以使用單一 RMW 實作
- 你需要最簡單的架構
- 每微秒都重要的效能關鍵應用程式
- 資源有限的嵌入式系統

**選擇 zenoh-plugin-ros2dds 當：**
- 你有使用 DDS 的現有 ROS 2 系統，無法輕易更改
- 你需要橋接不同的網路或域
- 你系統的某些部分必須使用 DDS（例如，第三方元件）
- 你想要從 DDS 逐漸遷移到 Zenoh
- 你需要以最少的配置更改連接跨網際網路的 ROS 2 系統
- 與 legacy 系統或混合供應商環境整合

### 部署模式比較

| 方面 | rmw_zenoh | zenoh-plugin-ros2dds |
|--------|---------------|---------------------|
| **設定複雜度** | 最小 - 只需更改 RMW_IMPLEMENTATION | 中等 - 需要 bridge 部署 |
| **效能** | 最高 - 沒有轉換開銷 | 高 - 有轉換成本 |
| **記憶體使用** | 低 - 單一協定堆疊 | 高 - 運行 DDS 和 Zenoh |
| **遷移路徑** | 全有或全無的切換 | 漸進地採用 |
| **混合環境** | 所有節點必須使用 rmw_zenoh | 可以橋接任何基於 DDS 的節點 |
| **探索開銷** | Zenoh 的高效探索 | 將 DDS 探索橋接到 Zenoh |

### 技術實作差異

**探索機制：**
```
rmw_zenoh:
ROS Node → Zenoh Session → Zenoh Router → Network

zenoh-plugin-ros2dds:
ROS Node → DDS → Bridge (DDS Reader/Writer) → Zenoh → Network
```

**訊息流：**
- **rmw_zenoh**：直接序列化為 Zenoh 格式
- **zenoh-plugin-ros2dds**：DDS 序列化 → 原始負載轉發 → DDS 反序列化

**配置：**
- **rmw_zenoh**：每個節點型別一個 JSON5 配置檔案
- **zenoh-plugin-ros2dds**：Bridge 特定配置加上現有的 DDS 設定

---

## 實作學習

最後我們來看一下即將在今年十月登場的 ROSCon 2025 [workshop](https://github.com/ZettaScaleLabs/roscon2025_workshop), 這個系列透過涵蓋以下內容，來展示了以下的主題：

- **實際模擬**：使用 Neobotix ROX 機器人完整的 Navigation2 與 Gazebo 整合
- **效能最佳化**：shared memory 配置和延遲測量的實作經驗
- **遠端連線**：跨網路和容器連接機器人的實際範例
- **安全整合**：安全機器人通訊的 mTLS 實作
- **網路韌性**：處理擁塞、封包遺失和無線網路挑戰的技術
- **網際網路穿越**：基於雲端的路由和 WAN 連接模式

強調 `rmw_zenoh` 不只是理論上的改進 —— 它是開發者可以立即部署的實用解決方案，而無需更改多少程式碼。

---

## 未來是分散式的——而且就在眼前

我們正在見證機器人學的根本轉變，**孤立的單機器人系統時代正在結束，** 未來的機器人在機器人群中運作，跨區域協作，並無縫整合雲端智慧與邊緣處理。

這種轉換需要能跟得上的通訊骨幹——**強健、高效且無限可擴展的**。`rmw_zenoh` 不只是應對這項挑戰；它正在定義什麼是可能的。

**如果你正在建構分散式機器人系統**，快來參與這份開源專案吧！ [rmw_zenoh](https://github.com/eclipse-zenoh/rmw_zenoh)
